# coding: utf-8

"""
    Grafana HTTP API.

    The Grafana backend exposes an HTTP API, the same API is used by the frontend to do everything from saving dashboards, creating users and updating data sources.  # noqa: E501

    OpenAPI spec version: 0.0.1
    Contact: hello@grafana.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class AnnotationsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_annotation_by_id(self, annotation_id, **kwargs):  # noqa: E501
        """Delete Annotation By ID.  # noqa: E501

        Deletes the annotation that matches the specified ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_annotation_by_id(annotation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str annotation_id: (required)
        :return: SuccessResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_annotation_by_id_with_http_info(annotation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_annotation_by_id_with_http_info(annotation_id, **kwargs)  # noqa: E501
            return data

    def delete_annotation_by_id_with_http_info(self, annotation_id, **kwargs):  # noqa: E501
        """Delete Annotation By ID.  # noqa: E501

        Deletes the annotation that matches the specified ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_annotation_by_id_with_http_info(annotation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str annotation_id: (required)
        :return: SuccessResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['annotation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_annotation_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'annotation_id' is set
        if self.api_client.client_side_validation and ('annotation_id' not in params or
                                                       params['annotation_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `annotation_id` when calling `delete_annotation_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'annotation_id' in params:
            path_params['annotation_id'] = params['annotation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic']  # noqa: E501

        return self.api_client.call_api(
            '/annotations/{annotation_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessResponseBody',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_annotation_by_id(self, annotation_id, **kwargs):  # noqa: E501
        """Get Annotation by Id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_annotation_by_id(annotation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str annotation_id: (required)
        :return: ItemDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_annotation_by_id_with_http_info(annotation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_annotation_by_id_with_http_info(annotation_id, **kwargs)  # noqa: E501
            return data

    def get_annotation_by_id_with_http_info(self, annotation_id, **kwargs):  # noqa: E501
        """Get Annotation by Id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_annotation_by_id_with_http_info(annotation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str annotation_id: (required)
        :return: ItemDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['annotation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_annotation_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'annotation_id' is set
        if self.api_client.client_side_validation and ('annotation_id' not in params or
                                                       params['annotation_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_annotation_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'annotation_id' in params:
            path_params['annotation_id'] = params['annotation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic']  # noqa: E501

        return self.api_client.call_api(
            '/annotations/{annotation_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ItemDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_annotation_tags(self, **kwargs):  # noqa: E501
        """Find Annotations Tags.  # noqa: E501

        Find all the event tags created in the annotations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_annotation_tags(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tag: Tag is a string that you can use to filter tags.
        :param str limit: Max limit for results returned.
        :return: GetAnnotationTagsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_annotation_tags_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_annotation_tags_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_annotation_tags_with_http_info(self, **kwargs):  # noqa: E501
        """Find Annotations Tags.  # noqa: E501

        Find all the event tags created in the annotations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_annotation_tags_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tag: Tag is a string that you can use to filter tags.
        :param str limit: Max limit for results returned.
        :return: GetAnnotationTagsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tag', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_annotation_tags" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic']  # noqa: E501

        return self.api_client.call_api(
            '/annotations/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAnnotationTagsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_annotations(self, **kwargs):  # noqa: E501
        """Find Annotations.  # noqa: E501

        Starting in Grafana v6.4 regions annotations are now returned in one entity that now includes the timeEnd property.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_annotations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int _from: Find annotations created after specific epoch datetime in milliseconds.
        :param int to: Find annotations created before specific epoch datetime in milliseconds.
        :param int user_id: Limit response to annotations created by specific user.
        :param int alert_id: Find annotations for a specified alert.
        :param int dashboard_id: Find annotations that are scoped to a specific dashboard
        :param str dashboard_uid: Find annotations that are scoped to a specific dashboard
        :param int panel_id: Find annotations that are scoped to a specific panel
        :param int limit: Max limit for results returned.
        :param list[str] tags: Use this to filter organization annotations. Organization annotations are annotations from an annotation data source that are not connected specifically to a dashboard or panel. You can filter by multiple tags.
        :param str type: Return alerts or user created annotations
        :param bool match_any: Match any or all tags
        :return: list[ItemDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_annotations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_annotations_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_annotations_with_http_info(self, **kwargs):  # noqa: E501
        """Find Annotations.  # noqa: E501

        Starting in Grafana v6.4 regions annotations are now returned in one entity that now includes the timeEnd property.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_annotations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int _from: Find annotations created after specific epoch datetime in milliseconds.
        :param int to: Find annotations created before specific epoch datetime in milliseconds.
        :param int user_id: Limit response to annotations created by specific user.
        :param int alert_id: Find annotations for a specified alert.
        :param int dashboard_id: Find annotations that are scoped to a specific dashboard
        :param str dashboard_uid: Find annotations that are scoped to a specific dashboard
        :param int panel_id: Find annotations that are scoped to a specific panel
        :param int limit: Max limit for results returned.
        :param list[str] tags: Use this to filter organization annotations. Organization annotations are annotations from an annotation data source that are not connected specifically to a dashboard or panel. You can filter by multiple tags.
        :param str type: Return alerts or user created annotations
        :param bool match_any: Match any or all tags
        :return: list[ItemDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['_from', 'to', 'user_id', 'alert_id', 'dashboard_id', 'dashboard_uid', 'panel_id', 'limit', 'tags', 'type', 'match_any']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_annotations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'alert_id' in params:
            query_params.append(('alertId', params['alert_id']))  # noqa: E501
        if 'dashboard_id' in params:
            query_params.append(('dashboardId', params['dashboard_id']))  # noqa: E501
        if 'dashboard_uid' in params:
            query_params.append(('dashboardUID', params['dashboard_uid']))  # noqa: E501
        if 'panel_id' in params:
            query_params.append(('panelId', params['panel_id']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'multi'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'match_any' in params:
            query_params.append(('matchAny', params['match_any']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic']  # noqa: E501

        return self.api_client.call_api(
            '/annotations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ItemDTO]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mass_delete_annotations(self, body, **kwargs):  # noqa: E501
        """Delete multiple annotations.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mass_delete_annotations(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MassDeleteAnnotationsCmd body: (required)
        :return: SuccessResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mass_delete_annotations_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.mass_delete_annotations_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def mass_delete_annotations_with_http_info(self, body, **kwargs):  # noqa: E501
        """Delete multiple annotations.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mass_delete_annotations_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MassDeleteAnnotationsCmd body: (required)
        :return: SuccessResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mass_delete_annotations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `mass_delete_annotations`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic']  # noqa: E501

        return self.api_client.call_api(
            '/annotations/mass-delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessResponseBody',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_annotation(self, annotation_id, body, **kwargs):  # noqa: E501
        """Patch Annotation  # noqa: E501

        Updates one or more properties of an annotation that matches the specified ID. This operation currently supports updating of the `text`, `tags`, `time` and `timeEnd` properties. This is available in Grafana 6.0.0-beta2 and above.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_annotation(annotation_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str annotation_id: (required)
        :param PatchAnnotationsCmd body: (required)
        :return: SuccessResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_annotation_with_http_info(annotation_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_annotation_with_http_info(annotation_id, body, **kwargs)  # noqa: E501
            return data

    def patch_annotation_with_http_info(self, annotation_id, body, **kwargs):  # noqa: E501
        """Patch Annotation  # noqa: E501

        Updates one or more properties of an annotation that matches the specified ID. This operation currently supports updating of the `text`, `tags`, `time` and `timeEnd` properties. This is available in Grafana 6.0.0-beta2 and above.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_annotation_with_http_info(annotation_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str annotation_id: (required)
        :param PatchAnnotationsCmd body: (required)
        :return: SuccessResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['annotation_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'annotation_id' is set
        if self.api_client.client_side_validation and ('annotation_id' not in params or
                                                       params['annotation_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `annotation_id` when calling `patch_annotation`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `patch_annotation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'annotation_id' in params:
            path_params['annotation_id'] = params['annotation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic']  # noqa: E501

        return self.api_client.call_api(
            '/annotations/{annotation_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessResponseBody',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_annotation(self, body, **kwargs):  # noqa: E501
        """Create Annotation.  # noqa: E501

        Creates an annotation in the Grafana database. The dashboardId and panelId fields are optional. If they are not specified then an organization annotation is created and can be queried in any dashboard that adds the Grafana annotations data source. When creating a region annotation include the timeEnd property. The format for `time` and `timeEnd` should be epoch numbers in millisecond resolution. The response for this HTTP request is slightly different in versions prior to v6.4. In prior versions you would also get an endId if you where creating a region. But in 6.4 regions are represented using a single event with time and timeEnd properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_annotation(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostAnnotationsCmd body: (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_annotation_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_annotation_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def post_annotation_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Annotation.  # noqa: E501

        Creates an annotation in the Grafana database. The dashboardId and panelId fields are optional. If they are not specified then an organization annotation is created and can be queried in any dashboard that adds the Grafana annotations data source. When creating a region annotation include the timeEnd property. The format for `time` and `timeEnd` should be epoch numbers in millisecond resolution. The response for this HTTP request is slightly different in versions prior to v6.4. In prior versions you would also get an endId if you where creating a region. But in 6.4 regions are represented using a single event with time and timeEnd properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_annotation_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostAnnotationsCmd body: (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `post_annotation`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic']  # noqa: E501

        return self.api_client.call_api(
            '/annotations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_graphite_annotation(self, body, **kwargs):  # noqa: E501
        """Create Annotation in Graphite format.  # noqa: E501

        Creates an annotation by using Graphite-compatible event format. The `when` and `data` fields are optional. If `when` is not specified then the current time will be used as annotation’s timestamp. The `tags` field can also be in prior to Graphite `0.10.0` format (string with multiple tags being separated by a space).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_graphite_annotation(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostGraphiteAnnotationsCmd body: (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_graphite_annotation_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_graphite_annotation_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def post_graphite_annotation_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Annotation in Graphite format.  # noqa: E501

        Creates an annotation by using Graphite-compatible event format. The `when` and `data` fields are optional. If `when` is not specified then the current time will be used as annotation’s timestamp. The `tags` field can also be in prior to Graphite `0.10.0` format (string with multiple tags being separated by a space).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_graphite_annotation_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostGraphiteAnnotationsCmd body: (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_graphite_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `post_graphite_annotation`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic']  # noqa: E501

        return self.api_client.call_api(
            '/annotations/graphite', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_annotation(self, annotation_id, body, **kwargs):  # noqa: E501
        """Update Annotation.  # noqa: E501

        Updates all properties of an annotation that matches the specified id. To only update certain property, consider using the Patch Annotation operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_annotation(annotation_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str annotation_id: (required)
        :param UpdateAnnotationsCmd body: (required)
        :return: SuccessResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_annotation_with_http_info(annotation_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_annotation_with_http_info(annotation_id, body, **kwargs)  # noqa: E501
            return data

    def update_annotation_with_http_info(self, annotation_id, body, **kwargs):  # noqa: E501
        """Update Annotation.  # noqa: E501

        Updates all properties of an annotation that matches the specified id. To only update certain property, consider using the Patch Annotation operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_annotation_with_http_info(annotation_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str annotation_id: (required)
        :param UpdateAnnotationsCmd body: (required)
        :return: SuccessResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['annotation_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'annotation_id' is set
        if self.api_client.client_side_validation and ('annotation_id' not in params or
                                                       params['annotation_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `annotation_id` when calling `update_annotation`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_annotation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'annotation_id' in params:
            path_params['annotation_id'] = params['annotation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic']  # noqa: E501

        return self.api_client.call_api(
            '/annotations/{annotation_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessResponseBody',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
