# coding: utf-8

"""
    Grafana HTTP API.

    The Grafana backend exposes an HTTP API, the same API is used by the frontend to do everything from saving dashboards, creating users and updating data sources.  # noqa: E501

    OpenAPI spec version: 0.0.1
    Contact: hello@grafana.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from swagger_client.configuration import Configuration


class FrameMeta(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'channel': 'str',
        'custom': 'object',
        'data_topic': 'DataTopic',
        'executed_query_string': 'str',
        'notices': 'list[Notice]',
        'path': 'str',
        'path_separator': 'str',
        'preferred_visualisation_type': 'VisType',
        'stats': 'list[QueryStat]',
        'type': 'FrameType'
    }

    attribute_map = {
        'channel': 'channel',
        'custom': 'custom',
        'data_topic': 'dataTopic',
        'executed_query_string': 'executedQueryString',
        'notices': 'notices',
        'path': 'path',
        'path_separator': 'pathSeparator',
        'preferred_visualisation_type': 'preferredVisualisationType',
        'stats': 'stats',
        'type': 'type'
    }

    def __init__(self, channel=None, custom=None, data_topic=None, executed_query_string=None, notices=None, path=None, path_separator=None, preferred_visualisation_type=None, stats=None, type=None, _configuration=None):  # noqa: E501
        """FrameMeta - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._channel = None
        self._custom = None
        self._data_topic = None
        self._executed_query_string = None
        self._notices = None
        self._path = None
        self._path_separator = None
        self._preferred_visualisation_type = None
        self._stats = None
        self._type = None
        self.discriminator = None

        if channel is not None:
            self.channel = channel
        if custom is not None:
            self.custom = custom
        if data_topic is not None:
            self.data_topic = data_topic
        if executed_query_string is not None:
            self.executed_query_string = executed_query_string
        if notices is not None:
            self.notices = notices
        if path is not None:
            self.path = path
        if path_separator is not None:
            self.path_separator = path_separator
        if preferred_visualisation_type is not None:
            self.preferred_visualisation_type = preferred_visualisation_type
        if stats is not None:
            self.stats = stats
        if type is not None:
            self.type = type

    @property
    def channel(self):
        """Gets the channel of this FrameMeta.  # noqa: E501

        Channel is the path to a stream in grafana live that has real-time updates for this data.  # noqa: E501

        :return: The channel of this FrameMeta.  # noqa: E501
        :rtype: str
        """
        return self._channel

    @channel.setter
    def channel(self, channel):
        """Sets the channel of this FrameMeta.

        Channel is the path to a stream in grafana live that has real-time updates for this data.  # noqa: E501

        :param channel: The channel of this FrameMeta.  # noqa: E501
        :type: str
        """

        self._channel = channel

    @property
    def custom(self):
        """Gets the custom of this FrameMeta.  # noqa: E501

        Custom datasource specific values.  # noqa: E501

        :return: The custom of this FrameMeta.  # noqa: E501
        :rtype: object
        """
        return self._custom

    @custom.setter
    def custom(self, custom):
        """Sets the custom of this FrameMeta.

        Custom datasource specific values.  # noqa: E501

        :param custom: The custom of this FrameMeta.  # noqa: E501
        :type: object
        """

        self._custom = custom

    @property
    def data_topic(self):
        """Gets the data_topic of this FrameMeta.  # noqa: E501


        :return: The data_topic of this FrameMeta.  # noqa: E501
        :rtype: DataTopic
        """
        return self._data_topic

    @data_topic.setter
    def data_topic(self, data_topic):
        """Sets the data_topic of this FrameMeta.


        :param data_topic: The data_topic of this FrameMeta.  # noqa: E501
        :type: DataTopic
        """

        self._data_topic = data_topic

    @property
    def executed_query_string(self):
        """Gets the executed_query_string of this FrameMeta.  # noqa: E501

        ExecutedQueryString is the raw query sent to the underlying system. All macros and templating have been applied.  When metadata contains this value, it will be shown in the query inspector.  # noqa: E501

        :return: The executed_query_string of this FrameMeta.  # noqa: E501
        :rtype: str
        """
        return self._executed_query_string

    @executed_query_string.setter
    def executed_query_string(self, executed_query_string):
        """Sets the executed_query_string of this FrameMeta.

        ExecutedQueryString is the raw query sent to the underlying system. All macros and templating have been applied.  When metadata contains this value, it will be shown in the query inspector.  # noqa: E501

        :param executed_query_string: The executed_query_string of this FrameMeta.  # noqa: E501
        :type: str
        """

        self._executed_query_string = executed_query_string

    @property
    def notices(self):
        """Gets the notices of this FrameMeta.  # noqa: E501

        Notices provide additional information about the data in the Frame that Grafana can display to the user in the user interface.  # noqa: E501

        :return: The notices of this FrameMeta.  # noqa: E501
        :rtype: list[Notice]
        """
        return self._notices

    @notices.setter
    def notices(self, notices):
        """Sets the notices of this FrameMeta.

        Notices provide additional information about the data in the Frame that Grafana can display to the user in the user interface.  # noqa: E501

        :param notices: The notices of this FrameMeta.  # noqa: E501
        :type: list[Notice]
        """

        self._notices = notices

    @property
    def path(self):
        """Gets the path of this FrameMeta.  # noqa: E501

        Path is a browsable path on the datasource.  # noqa: E501

        :return: The path of this FrameMeta.  # noqa: E501
        :rtype: str
        """
        return self._path

    @path.setter
    def path(self, path):
        """Sets the path of this FrameMeta.

        Path is a browsable path on the datasource.  # noqa: E501

        :param path: The path of this FrameMeta.  # noqa: E501
        :type: str
        """

        self._path = path

    @property
    def path_separator(self):
        """Gets the path_separator of this FrameMeta.  # noqa: E501

        PathSeparator defines the separator pattern to decode a hierarchy. The default separator is '/'.  # noqa: E501

        :return: The path_separator of this FrameMeta.  # noqa: E501
        :rtype: str
        """
        return self._path_separator

    @path_separator.setter
    def path_separator(self, path_separator):
        """Sets the path_separator of this FrameMeta.

        PathSeparator defines the separator pattern to decode a hierarchy. The default separator is '/'.  # noqa: E501

        :param path_separator: The path_separator of this FrameMeta.  # noqa: E501
        :type: str
        """

        self._path_separator = path_separator

    @property
    def preferred_visualisation_type(self):
        """Gets the preferred_visualisation_type of this FrameMeta.  # noqa: E501


        :return: The preferred_visualisation_type of this FrameMeta.  # noqa: E501
        :rtype: VisType
        """
        return self._preferred_visualisation_type

    @preferred_visualisation_type.setter
    def preferred_visualisation_type(self, preferred_visualisation_type):
        """Sets the preferred_visualisation_type of this FrameMeta.


        :param preferred_visualisation_type: The preferred_visualisation_type of this FrameMeta.  # noqa: E501
        :type: VisType
        """

        self._preferred_visualisation_type = preferred_visualisation_type

    @property
    def stats(self):
        """Gets the stats of this FrameMeta.  # noqa: E501

        Stats is an array of query result statistics.  # noqa: E501

        :return: The stats of this FrameMeta.  # noqa: E501
        :rtype: list[QueryStat]
        """
        return self._stats

    @stats.setter
    def stats(self, stats):
        """Sets the stats of this FrameMeta.

        Stats is an array of query result statistics.  # noqa: E501

        :param stats: The stats of this FrameMeta.  # noqa: E501
        :type: list[QueryStat]
        """

        self._stats = stats

    @property
    def type(self):
        """Gets the type of this FrameMeta.  # noqa: E501


        :return: The type of this FrameMeta.  # noqa: E501
        :rtype: FrameType
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this FrameMeta.


        :param type: The type of this FrameMeta.  # noqa: E501
        :type: FrameType
        """

        self._type = type

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(FrameMeta, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, FrameMeta):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, FrameMeta):
            return True

        return self.to_dict() != other.to_dict()
